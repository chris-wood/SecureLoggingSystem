\section{Log Design}
In this section we present our log generation and verification schemes.
They are influenced by past work done by Schneier et al \cite{Schneier1999-Secure},
Bellare et al. \cite{Bellare1997-ForwardIntegrity}, Ma et al. \cite{Ma2008-FssAgg},
and Yavuz et al. \cite{Yavuz2009-BAF}. 

\subsection{Log Construction}
\label{sec:LogConstruction}

Log integrity is achieved through hash chains and message-authentication codes. 
Each log entry is a five-tuple element that contains the generating source
information, the encrypted payload of the entry, a hash digest that provides
a link between the current and previous hash chain entries, and an authentication tag for this digest. In the proof-of-concept
system implementation, Keccak is used as the standalone hash function $H$
and the $HMAC$ function is built using $SHA$-$512$. 
Formally, each log entry $L_i$ is built using the following protocol (as depicted in Figure \ref{fig:hashChain}):
\begin{align*}
X_i = & H(X_{i - 1}, E_{SK}(D_i)) \\ % rationale: need to link this entry to previous for chaining
Y_i = & HMAC_{EpK_{j}}(X_i, Ep_{j}) \\ % rationale: for epoch-key based: can keep in logger memory and then commit on epoch cycle (helps against wiretapping attacks and load balancing)
L_i = & (U_{ID}, S_{ID}, E_{SK}(D_i), X_i, Y_i) % rationale for u/s: searhability
\end{align*}

\begin{figure*}[ht!]
  \centering
  \includegraphics[scale=0.8]{images/hashchain.pdf} \\
\caption{A visual depiction of the hash chain construction scheme. In this case, the epoch window is $5$ log entries, as shown by the epoch
cycle after $5$ consecutive log entries.}
\label{fig:hashChain}
\end{figure*}

In this scheme the $X_i$ elements are used to link together consecutive entries in 
the hash chain. Similarly, the $Y_i$ elements are used to provide authentication 
for the $X_i$ element using an authentication tag that is computed from $X_i$ and the 
previous epoch digest $Ep_{j - 1}$. 

In this context, an epoch $Ep_j$ simply corresponds to a fixed-size set of log entries that
are being processed (i.e. an epoch window). For example, if the epoch size is $n$ entries, then the 
log generation scheme will cycle after $n$ log entries have been constructed and begin working on a new set of log entries. After a cycle is completed, a context block
for the most recent epoch is created and inserted into an epoch chain (similar to the log chain). These log generation cycles create frames (or windows) in the entire log chain in which the 
scheme generates log entries using a single epoch block and key $Ep_{j}$ and $EpK_j$, respectively. 
More specifically, $Y_i$ is the authentication tag that is built using only the entries within the current epoch window.

%TODO: forward-secrecy guarantees... compare to aggregate signatures (we store each hash chain and the entire thing altogether)

%In order to provide computationally efficient means of generating the 
%authentication tag for the log chain, log generation is divided into epochs of
%client-defined sizes. The selection criteria for this epoch size is 
%discussed in more detail later, but should generally be based
%on the frequency of traffic that is generated by the host application. 

Context blocks for epoch windows are stored in the same way as log chains.
Each epoch chain entry $Ep_j$ is built as follows:
\begin{align*}
Ep_j = & HMAC_{EpK_{j}}(Ep_{j - 1}, L_{l}) \\
Ep_0 = & HMAC_{EpK_{0}}(0)
\end{align*}
In this context, $L_{l}$ is the last log chain entry for the previous epoch $Ep_{j - 1}$.
Thus, each epoch chain entry maintains the integrity of the log chain at each epoch cycle
by linking the most recent log chain entry to the previous epoch context block.
The key $EpK_{j}$ that is used to compute the $Y_i$ authentication tag is
based on the current epoch $Ep_j$, and only evolves when the epoch window cycles. 
This update is done with a pseudorandom function $H$ (which,
in our case, is simply the Keccak hash function), and is defined as follows:
\begin{align*}
EpK_{j + 1} = H(EpK_{j}) \\
\end{align*}
The initial epoch key $EpK_0$ is a secret that is initialized when a session
is started. Corruption of this key can enable a determined attacker to reconstruct
the log chain and epoch chain without detection. Without this information, however,
such modifications are always detectable. We refer to Section \ref{sec:security} for
a more detailed description of this issue.

Finally, as a third layer of integrity, a single digest for the entire log $T_i$
chain is stored as the log chain is iteratively constructed. Formally, $T_i$ is
built as follows:
\begin{align*}
T_i = & HMAC_{T_{K_{i}}}(L_{i}, T_{i - 1}) \\
T_0 = & HMAC_{T_{K_{0}}}(L_{i}, 1) %caw: this needs to change in the code. current code does not do it this way.
\end{align*}
The secret key $T_{K_{0}}$ for the entire log chain is another secret that is
initialized when the session is started. Similar to the epoch key, it is evolved
with a pseudorandom function $H$ as follows:
\begin{align*}
T_{K_{i + 1}} = H(T_{K_{i}})
\end{align*}

A visual representation of this protocol is shown in Figure \ref{fig:tagChain}. It is
important to note that a chain of $T_i$ elements is not maintained. Instead, only the
most recent element is persisted to the database. This is critical to prevent
truncation attacks.

\begin{figure*}[ht!]
  \centering
  \includegraphics[scale=0.8]{images/tagchain.pdf} \\
\caption{A visual depiction of the protocol used to build the log chain authentication tag.}
\label{fig:tagChain}
\end{figure*}

\subsection{Log Generation Rationale}
The construction of each log entry satisfies the following properties:
\begin{enumerate}
	\item Each log entry payload is encrypted and only viewable by those with the appropriate attributes.
	\item The integrity of the log chain is ensured through the links generated by $X_i$ elements, which are verifiable by the $Y_i$ authentication tags.
	\item The integrity of the entire log chain is guaranteed with the $T_i$ element. This protects the log chain against truncation attacks.
	\item The epoch-based log generation enables the logger to control the frequency of data
	sent to the log server, which helps with load balancing and protects against wiretapping attacks.
	\item The epoch window is assumed to be a fixed (constant) size, and thus it requires $\mathcal{O}(1)$ time to verify. The log chain can be verified in $\mathcal{O}(n)$ time, where $n$ is the length of the log chain. These results are discussed in Section \ref{log:ComputationalComplexity}.
	\item There are three different modes of verification that can be performed (weak, normal, and strongest). These modes are described in Section \ref{log:VerificationModes}.
	\item The log is searchable by the user identity and session numbers, which leads to very fine-grained database queries. 
\end{enumerate}

\begin{comment}
\subsection{Searchability}
Based on the definitions provided in Section \ref{sec:LogConstruction}, it is easy to 
see that log searchability is done by querying the database with known user identities and optional session 
identifiers. This was a tradeoff that we made to support reasonable auditing performance. 
It has been shown that in some application domains the presence of any relevant information
pertaining to users is a violation of security policies. However, since the entire entry payload
is kept confidential to unauthorized users through encryption, we do not anticipate the presence 
of this information causing many problems. 

The database schema for our logging system is shown in Figure \ref{fig:schema}. We emphasize that, 
if the log server were compromised, the only information that a determined attacker could retrieve from
the log database is a collection of user identities, which do not directly correspond to ``real'' user
identities (i.e. database user identities are GUIDs that are generated whenever a user account is created
by the host application). 
\end{comment}
